// 我们并不把滑动窗口的每个数值都存入队列中，而只把有可能成为滑动窗口最大值的数值存入到一个两端开口的队列。
// 接着以输入数字{2,3,4,2,6,2,5,1}为例一步分析。数组的第一个数字是 2，把它存入队列中。第二个数字是3.由于它比前一个数字 2 大，
// 因此 2不可能成为滑动窗口中的最大值。2 先从队列里删除，再把3存入到队列中。此时队列中只有一个数字 3。针对第三个数字 4 的步骤类似，
// 最终在队列中只剩下一个数字 4。此时滑动窗口中已经有 3 个数字，而它的最大值 4 位于队列的头部。接下来处理第四个数字 2。
// 2 比队列中的数字 4 小。当 4 滑出窗口之后 2 还是有可能成为滑动窗口的最大值，因此把 2 存入队列的尾部。现在队列中有两个数字 4 和 2，
// 其中最大值 4 仍然位于队列的头部。下一个数字是 6。由于它比队列中已有的数字 4 和 2 都大，因此这时 4 和 2 已经不可能成为滑动窗口中的最大值。
// 先把 4 和 2 从队列中删除，再把数字 6 存入队列。这个时候最大值 6 仍然位于队列的头部。第六个数字是 2。由于它比队列中已有的数字 6 小，所以 
// 2 也存入队列的尾部。此时队列中有两个数字，其中最大值 6 位于队列的头部。接下来的数字是 5。在队列中已有的两个数字 6 和 2 里，
// 2 小于 5，因此 2 不可能是一个滑动窗口的最大值，可以把它从队列的尾部删除。删除数字 2 之后，再把数字 5 存入队列。此时队列里剩下两个数字 6 
// 和 5，其中位于队列头部的是最大值 6。数组最后一个数字是 1，把 1 存入队列的尾部。注意到位于队列头部的数字 6 是数组的第 5 个数字，此时的
// 滑动窗口已经不包括这个数字了，因此应该把数字 6 从队列删除。那么怎么知道滑动窗口是否包括一个数字？应该在队列里存入数字在数组里的下标，而不是
// 数值。当一个数字的下标与当前处理的数字的下标之差大于或者等于滑动窗口的大小时，这个数字已经从滑动窗口中滑出，可以从队列中删除了。
    var maxSlidingWindow = function (nums, k) {
      const window = [];   //window存的是值的下标
      const result = [];
      for (let i = 0; i < nums.length; i++) {
         //如果当前处理的数字的下标减去队列头的下标的值大于或等于窗口长度，则该值不可能成为下一个窗口的最大值，将其移除
         //这个步骤一般是应用于目前队列里面所有的值都比当前值大的情况
        if (i - window[0] >= k ) {   
          window.shift();
        }
        let j = window.length - 1;
        // 如果当前数字大于队列尾，则删除队列尾，直到当前数字小于等于队列尾，或者队列空 
        // （保证窗口中左侧的值均大于当前入队列的值，这样做可以保证当下次循环窗口头部的元素出队后，窗口头部元素仍然为最大值
        while (j >= 0 && nums[window[j]] <= nums[i]) {
          j--;
          window.pop();
        }
        window.push(i);  //队列元素入队
        if (i >= k - 1) {  //当满一个窗口后向结果数组中添加值（队列头一定是最大值）
          result.push(nums[window[0]]);
        }
      }
      return result;
    };